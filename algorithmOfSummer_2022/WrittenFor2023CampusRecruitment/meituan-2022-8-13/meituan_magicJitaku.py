#  Author : Github: @GWillS163
#  Time: $(Date)
# 魔法外卖
# 时间限制： 3000MS
# 内存限制： 589824KB
# 题目描述：
# 炸鸡店拥有一名会传送魔法的外卖派送员。
#
# 该外卖派送员派送单子时，可以消耗时间t来正常派送单子（一次只能派送一个单子，不能多个同时派送），也可以使用魔法不耗费时间地隔空瞬间投送。
#
# 现在炸鸡店在时刻0接收到了若干炸鸡订单，每个单子都有它的截止送达时间。外卖派送员需要保证送达时间小于等于这个截止时间。
#
# 现在询问外卖员最少要使用几次魔法来保证没有外卖超时。
#
#
#
# 输入描述
# 第一行两个正整数n, t 以空格分开，表示当前接到了n个订单，外卖员在不使用魔法的情况下正常派送所需要消耗的时间t。
#
# 第二行n个正整数，每个正整数表示一个订单的截止送达时间。
#
# 1 <= n <= 1e5, 1 <= t <= 100, 订单的送达时间介于[1, 1e7]之间
#
# 输出描述
# 一行一个非负整数，表示外卖员最少需要使用的魔法次数。
#
#
# 样例输入
# 6 5
# 5 6 7 8 9 10
# 样例输出
# 4
#
# 提示
#
# 样例解释1
#
# 这个例子中，最少要使用魔法送达四个，比如送达时间为6，7，8，9这四个订单，然后正常送达5和10的两个订单。当然也存在其他的送达方法，但可以证明不存在小于需要用四次魔法的方法。
#
#
#
# 输入样例2
#
# 6 5
#
# 100 101 102 103 104 105
#
#
#
# 输出样例2
#
# 0

# 样例解释2
#
# 这个例子中，正常一个一个按顺序送就可以。不会超时。所以最少需要使用的魔法次数为零。

# orderNum_ddl = input().split()
# orderNum, tme = [int(n) for n in orderNum_ddl]
# order = [int(o) for o in input().split()]

orderNum_ddl = "6 10".split()
orderNum, tme = [int(n) for n in orderNum_ddl]
order = [5, 6, 7, 8, 9, 10, 90]

cannot_be_done = []
arrived = []
for o in order:
    if (len(arrived) + 1)*tme > o:  # 如果送过去会超时
        cannot_be_done.append(o)
    else:
        arrived.append(o)
print(len(cannot_be_done))
